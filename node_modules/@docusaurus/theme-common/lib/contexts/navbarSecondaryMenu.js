/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import React, { useState, useContext, useEffect, useMemo, useCallback, } from 'react';
import { ReactContextError, usePrevious } from '../utils/reactUtils';
import { useNavbarMobileSidebar } from './navbarMobileSidebar';
const InitialState = {
    shown: false,
    content: { component: null, props: null },
};
const Context = React.createContext(null);
function useContextValue() {
    const mobileSidebar = useNavbarMobileSidebar();
    const [state, setState] = useState(InitialState);
    const setShown = (shown) => setState((s) => ({ ...s, shown }));
    const hasContent = state.content?.component !== null;
    const previousHasContent = usePrevious(state.content?.component !== null);
    // When content is become available for the first time (set in useEffect)
    // we set this content to be shown!
    useEffect(() => {
        const contentBecameAvailable = hasContent && !previousHasContent;
        if (contentBecameAvailable) {
            setShown(true);
        }
    }, [hasContent, previousHasContent]);
    // On sidebar close, secondary menu is set to be shown on next re-opening
    // (if any secondary menu content available)
    useEffect(() => {
        if (!hasContent) {
            setShown(false);
            return;
        }
        if (!mobileSidebar.shown) {
            setShown(true);
        }
    }, [mobileSidebar.shown, hasContent]);
    return [state, setState];
}
export function NavbarSecondaryMenuProvider({ children, }) {
    const value = useContextValue();
    return React.createElement(Context.Provider, { value: value }, children);
}
function useNavbarSecondaryMenuContext() {
    const value = useContext(Context);
    if (value === null) {
        throw new ReactContextError('MobileSecondaryMenuProvider');
    }
    return value;
}
function useShallowMemoizedObject(obj) {
    return useMemo(() => obj, 
    // Is this safe?
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...Object.keys(obj), ...Object.values(obj)]);
}
/**
 * This component renders nothing by itself, but it fills the placeholder in the
 * generic secondary menu layout. This reduces coupling between the main layout
 * and the specific page.
 *
 * This kind of feature is often called portal/teleport/gateway/outlet...
 * Various unmaintained React libs exist. Most up-to-date one:
 * https://github.com/gregberge/react-teleporter
 * Not sure any of those is safe regarding concurrent mode.
 */
export function NavbarSecondaryMenuFiller({ component, props, }) {
    const [, setState] = useNavbarSecondaryMenuContext();
    // To avoid useless context re-renders, props are memoized shallowly
    const memoizedProps = useShallowMemoizedObject(props);
    useEffect(() => {
        // @ts-expect-error: context is not 100% type-safe but it's ok
        setState((s) => ({ ...s, content: { component, props: memoizedProps } }));
    }, [setState, component, memoizedProps]);
    useEffect(() => () => setState((s) => ({ ...s, component: null, props: null })), [setState]);
    return null;
}
function renderElement(state) {
    if (state.content?.component) {
        const Comp = state.content.component;
        return React.createElement(Comp, { ...state.content.props });
    }
    return undefined;
}
/** Wires the logic for rendering the mobile navbar secondary menu. */
export function useNavbarSecondaryMenu() {
    const [state, setState] = useNavbarSecondaryMenuContext();
    const hide = useCallback(() => setState((s) => ({ ...s, shown: false })), [setState]);
    return useMemo(() => ({ shown: state.shown, hide, content: renderElement(state) }), [hide, state]);
}
//# sourceMappingURL=navbarSecondaryMenu.js.map