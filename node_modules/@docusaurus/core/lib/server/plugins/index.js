"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPlugins = exports.sortConfig = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@docusaurus/utils");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const init_1 = tslib_1.__importDefault(require("./init"));
const logger_1 = tslib_1.__importDefault(require("@docusaurus/logger"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const translations_1 = require("../translations/translations");
const applyRouteTrailingSlash_1 = tslib_1.__importDefault(require("./applyRouteTrailingSlash"));
function sortConfig(routeConfigs, baseUrl = '/') {
    // Sort the route config. This ensures that route with nested
    // routes is always placed last.
    routeConfigs.sort((a, b) => {
        // Root route should get placed last.
        if (a.path === baseUrl && b.path !== baseUrl) {
            return 1;
        }
        if (a.path !== baseUrl && b.path === baseUrl) {
            return -1;
        }
        if (a.routes && !b.routes) {
            return 1;
        }
        if (!a.routes && b.routes) {
            return -1;
        }
        // Higher priority get placed first.
        if (a.priority || b.priority) {
            const priorityA = a.priority || 0;
            const priorityB = b.priority || 0;
            const score = priorityB - priorityA;
            if (score !== 0) {
                return score;
            }
        }
        return a.path.localeCompare(b.path);
    });
    routeConfigs.forEach((routeConfig) => {
        routeConfig.routes?.sort((a, b) => a.path.localeCompare(b.path));
    });
}
exports.sortConfig = sortConfig;
async function loadPlugins({ pluginConfigs, context, }) {
    // 1. Plugin Lifecycle - Initialization/Constructor.
    const plugins = await (0, init_1.default)({
        pluginConfigs,
        context,
    });
    // 2. Plugin Lifecycle - loadContent.
    // Currently plugins run lifecycle methods in parallel and are not
    // order-dependent. We could change this in future if there are plugins which
    // need to run in certain order or depend on others for data.
    const loadedPlugins = await Promise.all(plugins.map(async (plugin) => {
        const content = await plugin.loadContent?.();
        return { ...plugin, content };
    }));
    const contentLoadedTranslatedPlugins = await Promise.all(loadedPlugins.map(async (contentLoadedPlugin) => {
        const translationFiles = (await contentLoadedPlugin?.getTranslationFiles?.({
            content: contentLoadedPlugin.content,
        })) ?? [];
        const localizedTranslationFiles = await Promise.all(translationFiles.map((translationFile) => (0, translations_1.localizePluginTranslationFile)({
            locale: context.i18n.currentLocale,
            siteDir: context.siteDir,
            translationFile,
            plugin: contentLoadedPlugin,
        })));
        return {
            ...contentLoadedPlugin,
            translationFiles: localizedTranslationFiles,
        };
    }));
    const allContent = lodash_1.default.chain(loadedPlugins)
        .groupBy((item) => item.name)
        .mapValues((nameItems) => lodash_1.default.chain(nameItems)
        .groupBy((item) => item.options.id)
        .mapValues((idItems) => idItems[0].content)
        .value())
        .value();
    // 3. Plugin Lifecycle - contentLoaded.
    const pluginsRouteConfigs = [];
    const globalData = {};
    await Promise.all(contentLoadedTranslatedPlugins.map(async ({ content, translationFiles, ...plugin }) => {
        if (!plugin.contentLoaded) {
            return;
        }
        const pluginId = plugin.options.id;
        // plugins data files are namespaced by pluginName/pluginId
        const dataDirRoot = path_1.default.join(context.generatedFilesDir, plugin.name);
        const dataDir = path_1.default.join(dataDirRoot, pluginId);
        const createData = async (name, data) => {
            const modulePath = path_1.default.join(dataDir, name);
            await fs_extra_1.default.ensureDir(path_1.default.dirname(modulePath));
            await (0, utils_1.generate)(dataDir, name, data);
            return modulePath;
        };
        // TODO this would be better to do all that in the codegen phase
        // TODO handle context for nested routes
        const pluginRouteContext = {
            plugin: { name: plugin.name, id: pluginId },
            data: undefined, // TODO allow plugins to provide context data
        };
        const pluginRouteContextModulePath = await createData(`${(0, utils_1.docuHash)('pluginRouteContextModule')}.json`, JSON.stringify(pluginRouteContext, null, 2));
        const addRoute = (initialRouteConfig) => {
            // Trailing slash behavior is handled in a generic way for all plugins
            const finalRouteConfig = (0, applyRouteTrailingSlash_1.default)(initialRouteConfig, {
                trailingSlash: context.siteConfig.trailingSlash,
                baseUrl: context.siteConfig.baseUrl,
            });
            pluginsRouteConfigs.push({
                ...finalRouteConfig,
                modules: {
                    ...finalRouteConfig.modules,
                    __routeContextModule: pluginRouteContextModulePath,
                },
            });
        };
        // the plugins global data are namespaced to avoid data conflicts:
        // - by plugin name
        // - by plugin id (allow using multiple instances of the same plugin)
        const setGlobalData = (data) => {
            globalData[plugin.name] = globalData[plugin.name] ?? {};
            globalData[plugin.name][pluginId] = data;
        };
        const actions = {
            addRoute,
            createData,
            setGlobalData,
        };
        const translatedContent = plugin.translateContent?.({ content, translationFiles }) ?? content;
        await plugin.contentLoaded({
            content: translatedContent,
            actions,
            allContent,
        });
    }));
    // 4. Plugin Lifecycle - routesLoaded.
    // Currently plugins run lifecycle methods in parallel and are not
    // order-dependent. We could change this in future if there are plugins which
    // need to run in certain order or depend on others for data.
    await Promise.all(contentLoadedTranslatedPlugins.map(async (plugin) => {
        if (!plugin.routesLoaded) {
            return;
        }
        // TODO remove this deprecated lifecycle soon
        // deprecated since alpha-60
        // TODO, 1 user reported usage of this lifecycle! https://github.com/facebook/docusaurus/issues/3918
        logger_1.default.error `Plugin code=${'routesLoaded'} lifecycle is deprecated. If you think we should keep this lifecycle, please report here: path=${'https://github.com/facebook/docusaurus/issues/3918'}`;
        await plugin.routesLoaded(pluginsRouteConfigs);
    }));
    // Sort the route config. This ensures that route with nested
    // routes are always placed last.
    sortConfig(pluginsRouteConfigs, context.siteConfig.baseUrl);
    // Apply each plugin one after the other to translate the theme config
    function translateThemeConfig(untranslatedThemeConfig) {
        return contentLoadedTranslatedPlugins.reduce((currentThemeConfig, plugin) => {
            const translatedThemeConfigSlice = plugin.translateThemeConfig?.({
                themeConfig: currentThemeConfig,
                translationFiles: plugin.translationFiles,
            });
            return {
                ...currentThemeConfig,
                ...translatedThemeConfigSlice,
            };
        }, untranslatedThemeConfig);
    }
    return {
        plugins: loadedPlugins,
        pluginsRouteConfigs,
        globalData,
        themeConfigTranslated: translateThemeConfig(context.siteConfig.themeConfig),
    };
}
exports.loadPlugins = loadPlugins;
