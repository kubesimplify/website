"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = exports.loadPluginConfigs = exports.loadContext = exports.loadSiteConfig = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("@docusaurus/utils");
const path_1 = tslib_1.__importDefault(require("path"));
const logger_1 = tslib_1.__importDefault(require("@docusaurus/logger"));
const ssr_html_template_1 = tslib_1.__importDefault(require("../webpack/templates/ssr.html.template"));
const client_modules_1 = tslib_1.__importDefault(require("./client-modules"));
const config_1 = tslib_1.__importDefault(require("./config"));
const plugins_1 = require("./plugins");
const presets_1 = tslib_1.__importDefault(require("./presets"));
const routes_1 = tslib_1.__importDefault(require("./routes"));
const html_tags_1 = require("./html-tags");
const versions_1 = require("./versions");
const duplicateRoutes_1 = require("./duplicateRoutes");
const i18n_1 = require("./i18n");
const translations_1 = require("./translations/translations");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const remark_admonitions_1 = tslib_1.__importDefault(require("remark-admonitions"));
const module_1 = require("module");
const moduleShorthand_1 = require("./moduleShorthand");
async function loadSiteConfig({ siteDir, customConfigFilePath, }) {
    const siteConfigPath = path_1.default.resolve(siteDir, customConfigFilePath ?? utils_1.DEFAULT_CONFIG_FILE_NAME);
    const siteConfig = await (0, config_1.default)(siteConfigPath);
    return { siteConfig, siteConfigPath };
}
exports.loadSiteConfig = loadSiteConfig;
async function loadContext(siteDir, options = {}) {
    const { customOutDir, locale, customConfigFilePath } = options;
    const generatedFilesDir = path_1.default.resolve(siteDir, utils_1.GENERATED_FILES_DIR_NAME);
    const { siteConfig: initialSiteConfig, siteConfigPath } = await loadSiteConfig({
        siteDir,
        customConfigFilePath,
    });
    const { ssrTemplate } = initialSiteConfig;
    const baseOutDir = path_1.default.resolve(siteDir, customOutDir ?? utils_1.DEFAULT_BUILD_DIR_NAME);
    const i18n = await (0, i18n_1.loadI18n)(initialSiteConfig, { locale });
    const baseUrl = (0, i18n_1.localizePath)({
        path: initialSiteConfig.baseUrl,
        i18n,
        options,
        pathType: 'url',
    });
    const outDir = (0, i18n_1.localizePath)({
        path: baseOutDir,
        i18n,
        options,
        pathType: 'fs',
    });
    const siteConfig = { ...initialSiteConfig, baseUrl };
    const codeTranslationFileContent = (await (0, translations_1.readCodeTranslationFileContent)({
        siteDir,
        locale: i18n.currentLocale,
    })) ?? {};
    // We only need key->message for code translations
    const codeTranslations = lodash_1.default.mapValues(codeTranslationFileContent, (value) => value.message);
    return {
        siteDir,
        generatedFilesDir,
        siteConfig,
        siteConfigPath,
        outDir,
        baseUrl,
        i18n,
        ssrTemplate: ssrTemplate ?? ssr_html_template_1.default,
        codeTranslations,
    };
}
exports.loadContext = loadContext;
async function loadPluginConfigs(context) {
    let { plugins: presetPlugins, themes: presetThemes } = await (0, presets_1.default)(context);
    const { siteConfig, siteConfigPath } = context;
    const require = (0, module_1.createRequire)(siteConfigPath);
    function normalizeShorthand(pluginConfig, pluginType) {
        if (typeof pluginConfig === 'string') {
            return (0, moduleShorthand_1.resolveModuleName)(pluginConfig, require, pluginType);
        }
        else if (Array.isArray(pluginConfig) &&
            typeof pluginConfig[0] === 'string') {
            return [
                (0, moduleShorthand_1.resolveModuleName)(pluginConfig[0], require, pluginType),
                pluginConfig[1] ?? {},
            ];
        }
        return pluginConfig;
    }
    presetPlugins = presetPlugins.map((plugin) => normalizeShorthand(plugin, 'plugin'));
    presetThemes = presetThemes.map((theme) => normalizeShorthand(theme, 'theme'));
    const standalonePlugins = siteConfig.plugins.map((plugin) => normalizeShorthand(plugin, 'plugin'));
    const standaloneThemes = siteConfig.themes.map((theme) => normalizeShorthand(theme, 'theme'));
    return [
        ...presetPlugins,
        ...presetThemes,
        // Site config should be the highest priority.
        ...standalonePlugins,
        ...standaloneThemes,
    ];
}
exports.loadPluginConfigs = loadPluginConfigs;
// Make a fake plugin to:
// - Resolve aliased theme components
// - Inject scripts/stylesheets
function createBootstrapPlugin({ siteDir, siteConfig, }) {
    const { stylesheets, scripts, clientModules: siteConfigClientModules, } = siteConfig;
    return {
        name: 'docusaurus-bootstrap-plugin',
        content: null,
        options: {
            id: 'default',
        },
        version: { type: 'synthetic' },
        path: siteDir,
        getClientModules() {
            return siteConfigClientModules;
        },
        injectHtmlTags: () => {
            const stylesheetsTags = stylesheets.map((source) => typeof source === 'string'
                ? `<link rel="stylesheet" href="${source}">`
                : {
                    tagName: 'link',
                    attributes: {
                        rel: 'stylesheet',
                        ...source,
                    },
                });
            const scriptsTags = scripts.map((source) => typeof source === 'string'
                ? `<script src="${source}"></script>`
                : {
                    tagName: 'script',
                    attributes: {
                        ...source,
                    },
                });
            return {
                headTags: [...stylesheetsTags, ...scriptsTags],
            };
        },
    };
}
/**
 * Configure Webpack fallback mdx loader for md/mdx files out of content-plugin
 * folders. Adds a "fallback" mdx loader for mdx files that are not processed by
 * content plugins. This allows to do things such as importing repo/README.md as
 * a partial from another doc. Not ideal solution, but good enough for now
 */
function createMDXFallbackPlugin({ siteDir, siteConfig, }) {
    return {
        name: 'docusaurus-mdx-fallback-plugin',
        content: null,
        options: {
            id: 'default',
        },
        version: { type: 'synthetic' },
        // Synthetic, the path doesn't matter much
        path: '.',
        configureWebpack(config, isServer, { getJSLoader }) {
            // We need the mdx fallback loader to exclude files that were already
            // processed by content plugins mdx loaders. This works, but a bit
            // hacky... Not sure there's a way to handle that differently in webpack
            function getMDXFallbackExcludedPaths() {
                const rules = config?.module?.rules;
                return rules.flatMap((rule) => {
                    const isMDXRule = rule.test instanceof RegExp && rule.test.test('x.mdx');
                    return isMDXRule ? rule.include : [];
                });
            }
            return {
                module: {
                    rules: [
                        {
                            test: /\.mdx?$/i,
                            exclude: getMDXFallbackExcludedPaths(),
                            use: [
                                getJSLoader({ isServer }),
                                {
                                    loader: require.resolve('@docusaurus/mdx-loader'),
                                    options: {
                                        staticDirs: siteConfig.staticDirectories.map((dir) => path_1.default.resolve(siteDir, dir)),
                                        siteDir,
                                        isMDXPartial: () => true,
                                        isMDXPartialFrontMatterWarningDisabled: true,
                                        remarkPlugins: [remark_admonitions_1.default],
                                    },
                                },
                            ],
                        },
                    ],
                },
            };
        },
    };
}
async function load(siteDir, options = {}) {
    // Context.
    const context = await loadContext(siteDir, options);
    const { generatedFilesDir, siteConfig, siteConfigPath, outDir, baseUrl, i18n, ssrTemplate, codeTranslations, } = context;
    // Plugins.
    const pluginConfigs = await loadPluginConfigs(context);
    const { plugins, pluginsRouteConfigs, globalData, themeConfigTranslated } = await (0, plugins_1.loadPlugins)({ pluginConfigs, context });
    // Side-effect to replace the untranslated themeConfig by the translated one
    context.siteConfig.themeConfig = themeConfigTranslated;
    (0, duplicateRoutes_1.handleDuplicateRoutes)(pluginsRouteConfigs, siteConfig.onDuplicateRoutes);
    const genWarning = (0, utils_1.generate)(generatedFilesDir, 'DONT-EDIT-THIS-FOLDER', `This folder stores temp files that Docusaurus' client bundler accesses.

DO NOT hand-modify files in this folder because they will be overwritten in the
next build. You can clear all build artifacts (including this folder) with the
\`docusaurus clear\` command.
`);
    // Site config must be generated after plugins
    // We want the generated config to have been normalized by the plugins!
    const genSiteConfig = (0, utils_1.generate)(generatedFilesDir, utils_1.DEFAULT_CONFIG_FILE_NAME, `/*
 * AUTOGENERATED - DON'T EDIT
 * Your edits in this file will be overwritten in the next build!
 * Modify the docusaurus.config.js file at your site's root instead.
 */
export default ${JSON.stringify(siteConfig, null, 2)};
`);
    plugins.push(createBootstrapPlugin({ siteDir, siteConfig }), createMDXFallbackPlugin({ siteDir, siteConfig }));
    // Load client modules.
    const clientModules = (0, client_modules_1.default)(plugins);
    const genClientModules = (0, utils_1.generate)(generatedFilesDir, 'client-modules.js', `export default [
${clientModules
        // import() is async so we use require() because client modules can have
        // CSS and the order matters for loading CSS.
        .map((module) => `  require('${(0, utils_1.escapePath)(module)}'),`)
        .join('\n')}
];
`);
    // Load extra head & body html tags.
    const { headTags, preBodyTags, postBodyTags } = (0, html_tags_1.loadHtmlTags)(plugins);
    // Routing.
    const { registry, routesChunkNames, routesConfig, routesPaths } = await (0, routes_1.default)(pluginsRouteConfigs, baseUrl);
    const genRegistry = (0, utils_1.generate)(generatedFilesDir, 'registry.js', `export default {
${Object.entries(registry)
        .sort((a, b) => a[0].localeCompare(b[0]))
        .map(([key, chunk]) => `  '${key}': [${chunk.loader}, '${(0, utils_1.escapePath)(chunk.modulePath)}', require.resolveWeak('${(0, utils_1.escapePath)(chunk.modulePath)}')],`)
        .join('\n')}};
`);
    const genRoutesChunkNames = (0, utils_1.generate)(generatedFilesDir, 'routesChunkNames.json', JSON.stringify(routesChunkNames, null, 2));
    const genRoutes = (0, utils_1.generate)(generatedFilesDir, 'routes.js', routesConfig);
    const genGlobalData = (0, utils_1.generate)(generatedFilesDir, 'globalData.json', JSON.stringify(globalData, null, 2));
    const genI18n = (0, utils_1.generate)(generatedFilesDir, 'i18n.json', JSON.stringify(i18n, null, 2));
    const codeTranslationsWithFallbacks = {
        ...(await (0, translations_1.getPluginsDefaultCodeTranslationMessages)(plugins)),
        ...codeTranslations,
    };
    const genCodeTranslations = (0, utils_1.generate)(generatedFilesDir, 'codeTranslations.json', JSON.stringify(codeTranslationsWithFallbacks, null, 2));
    // Version metadata.
    const siteMetadata = {
        docusaurusVersion: (await (0, versions_1.getPackageJsonVersion)(path_1.default.join(__dirname, '../../package.json'))),
        siteVersion: await (0, versions_1.getPackageJsonVersion)(path_1.default.join(siteDir, 'package.json')),
        pluginVersions: {},
    };
    plugins
        .filter(({ version: { type } }) => type !== 'synthetic')
        .forEach(({ name, version }) => {
        siteMetadata.pluginVersions[name] = version;
    });
    checkDocusaurusPackagesVersion(siteMetadata);
    const genSiteMetadata = (0, utils_1.generate)(generatedFilesDir, 'site-metadata.json', JSON.stringify(siteMetadata, null, 2));
    await Promise.all([
        genWarning,
        genClientModules,
        genSiteConfig,
        genRegistry,
        genRoutesChunkNames,
        genRoutes,
        genGlobalData,
        genSiteMetadata,
        genI18n,
        genCodeTranslations,
    ]);
    const props = {
        siteConfig,
        siteConfigPath,
        siteMetadata,
        siteDir,
        outDir,
        baseUrl,
        i18n,
        generatedFilesDir,
        routes: pluginsRouteConfigs,
        routesPaths,
        plugins,
        headTags,
        preBodyTags,
        postBodyTags,
        ssrTemplate,
        codeTranslations,
    };
    return props;
}
exports.load = load;
// We want all @docusaurus/* packages to have the exact same version!
// See https://github.com/facebook/docusaurus/issues/3371
// See https://github.com/facebook/docusaurus/pull/3386
function checkDocusaurusPackagesVersion(siteMetadata) {
    const { docusaurusVersion } = siteMetadata;
    Object.entries(siteMetadata.pluginVersions).forEach(([plugin, versionInfo]) => {
        if (versionInfo.type === 'package' &&
            versionInfo.name?.startsWith('@docusaurus/') &&
            versionInfo.version &&
            versionInfo.version !== docusaurusVersion) {
            // should we throw instead?
            // It still could work with different versions
            logger_1.default.error `Invalid name=${plugin} version number=${versionInfo.version}.
All official @docusaurus/* packages should have the exact same version as @docusaurus/core (number=${docusaurusVersion}).
Maybe you want to check, or regenerate your yarn.lock or package-lock.json file?`;
        }
    });
}
